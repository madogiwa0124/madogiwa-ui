import { defineComponent as r, createElementBlock as l, openBlock as n, normalizeClass as c, createBlock as f, createCommentVNode as h, unref as i, withCtx as d, renderSlot as o, computed as y, resolveDynamicComponent as D, useModel as g, withDirectives as B, vModelCheckbox as S, ref as k, watch as L, onMounted as A, mergeModels as O, vModelDynamic as R, onUnmounted as x, useTemplateRef as T, watchEffect as E, createVNode as I, vModelRadio as F, vModelSelect as U, vModelText as P } from "vue";
const tt = /* @__PURE__ */ r({
  __name: "MAccordion",
  props: {
    transition: { type: Boolean, default: !1 },
    outline: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("details", {
      class: c(["m-accordion", [
        { "--transition": e.transition },
        { "--outline": e.outline }
      ]])
    }, [
      t.$slots.summary ? (n(), f(i(G), { key: 0 }, {
        default: d(() => [
          o(t.$slots, "summary")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.default ? (n(), f(i(z), { key: 1 }, {
        default: d(() => [
          o(t.$slots, "default")
        ]),
        _: 3
      })) : h("", !0)
    ], 2));
  }
}), q = { class: "m-accordion__summary" }, G = /* @__PURE__ */ r({
  __name: "MAccordionSummary",
  setup(e) {
    return (t, a) => (n(), l("summary", q, [
      o(t.$slots, "default")
    ]));
  }
}), j = { class: "m-accordion__content" }, z = /* @__PURE__ */ r({
  __name: "MAccordionContent",
  setup(e) {
    return (t, a) => (n(), l("div", j, [
      o(t.$slots, "default")
    ]));
  }
}), W = ["data-auto-dismiss"], at = /* @__PURE__ */ r({
  __name: "MAlert",
  props: {
    variant: { default: null },
    withProgress: { type: Boolean, default: !1 },
    autoDismiss: { default: null }
  },
  setup(e) {
    return (t, a) => (n(), l("div", {
      class: c(["m-alert", [
        e.variant ? `--${e.variant}` : "",
        { "--with-progress": e.withProgress }
      ]]),
      role: "alert",
      "data-auto-dismiss": e.autoDismiss
    }, [
      t.$slots.icons ? (n(), f(i(Z), { key: 0 }, {
        default: d(() => [
          o(t.$slots, "icons")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.default ? (n(), f(i(X), { key: 1 }, {
        default: d(() => [
          o(t.$slots, "default")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.actions ? (n(), f(i(K), { key: 2 }, {
        default: d(() => [
          o(t.$slots, "actions")
        ]),
        _: 3
      })) : h("", !0)
    ], 10, W));
  }
}), J = { class: "m-alert__actions" }, K = /* @__PURE__ */ r({
  __name: "MAlertActions",
  setup(e) {
    return (t, a) => (n(), l("div", J, [
      o(t.$slots, "default")
    ]));
  }
}), Q = { class: "m-alert__content" }, X = /* @__PURE__ */ r({
  __name: "MAlertContent",
  setup(e) {
    return (t, a) => (n(), l("div", Q, [
      o(t.$slots, "default")
    ]));
  }
}), Y = { class: "m-alert__icons" }, Z = /* @__PURE__ */ r({
  __name: "MAlertIcons",
  setup(e) {
    return (t, a) => (n(), l("div", Y, [
      o(t.$slots, "default")
    ]));
  }
}), nt = /* @__PURE__ */ r({
  __name: "MBadge",
  props: {
    as: { default: "span" },
    variant: { default: null },
    outline: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = y(() => [
      "m-badge",
      e.variant ? `--${e.variant}` : "",
      { "--outline": e.outline },
      { "--small": e.small },
      { "--rounded": e.rounded },
      { "--transition": e.transition }
    ]);
    return (a, s) => (n(), f(D(e.as), {
      class: c(t.value)
    }, {
      default: d(() => [
        o(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), st = /* @__PURE__ */ r({
  __name: "MBtn",
  props: {
    variant: { default: null },
    outline: { type: Boolean, default: !1 },
    block: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    iconOnly: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("button", {
      class: c(["m-btn", [
        e.variant ? `--${e.variant}` : "",
        { "--outline": e.outline },
        { "--block": e.block },
        { "--rounded": e.rounded },
        { "--icon-only": e.iconOnly },
        { "--transition": e.transition }
      ]])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), ot = /* @__PURE__ */ r({
  __name: "MCard",
  props: {
    floating: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("div", {
      class: c(["m-card", [
        { "--floating": e.floating }
      ]])
    }, [
      o(t.$slots, "image"),
      t.$slots.default ? (n(), f(i(ne), { key: 0 }, {
        default: d(() => [
          o(t.$slots, "default")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.footer ? (n(), f(i(te), { key: 1 }, {
        default: d(() => [
          o(t.$slots, "footer")
        ]),
        _: 3
      })) : h("", !0)
    ], 2));
  }
}), ee = { class: "m-card__footer" }, te = /* @__PURE__ */ r({
  __name: "MCardFooter",
  setup(e) {
    return (t, a) => (n(), l("div", ee, [
      o(t.$slots, "default")
    ]));
  }
}), ae = { class: "m-card__content" }, ne = /* @__PURE__ */ r({
  __name: "MCardContent",
  setup(e) {
    return (t, a) => (n(), l("div", ae, [
      o(t.$slots, "default")
    ]));
  }
}), se = ["src", "alt"], lt = /* @__PURE__ */ r({
  __name: "MCardImage",
  props: {
    src: {},
    alt: {}
  },
  setup(e) {
    return (t, a) => (n(), l("img", {
      class: "m-card__image",
      src: e.src,
      alt: e.alt
    }, null, 8, se));
  }
}), rt = /* @__PURE__ */ r({
  __name: "MCheckbox",
  props: {
    modelValue: { type: Boolean },
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (u) => t.value = u),
      type: "checkbox",
      class: "m-checkbox"
    }, null, 512)), [
      [S, t.value]
    ]);
  }
}), ut = /* @__PURE__ */ r({
  __name: "MDialog",
  props: {
    open: { type: Boolean, default: !1 },
    backdropBlur: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    const a = t, s = k(null);
    L(() => e.open, ($) => {
      s.value && ($ ? s.value.showModal() : s.value.close());
    });
    const u = () => {
      a("close");
    };
    return A(() => {
      e.open && s.value && s.value.showModal();
    }), ($, p) => (n(), l("dialog", {
      ref_key: "dialogRef",
      ref: s,
      class: c(["m-dialog", [
        { "--backdrop-blur": e.backdropBlur },
        { "--transition": e.transition }
      ]]),
      onClose: u
    }, [
      o($.$slots, "default")
    ], 34));
  }
}), _ = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [s, u] of t)
    a[s] = u;
  return a;
}, oe = {}, le = { class: "m-h1" };
function re(e, t) {
  return n(), l("h1", le, [
    o(e.$slots, "default")
  ]);
}
const ct = /* @__PURE__ */ _(oe, [["render", re]]), ue = {}, ce = { class: "m-h2" };
function ie(e, t) {
  return n(), l("h2", ce, [
    o(e.$slots, "default")
  ]);
}
const it = /* @__PURE__ */ _(ue, [["render", ie]]), de = {}, me = { class: "m-h3" };
function fe(e, t) {
  return n(), l("h3", me, [
    o(e.$slots, "default")
  ]);
}
const dt = /* @__PURE__ */ _(de, [["render", fe]]), _e = {}, $e = { class: "m-h4" };
function he(e, t) {
  return n(), l("h4", $e, [
    o(e.$slots, "default")
  ]);
}
const mt = /* @__PURE__ */ _(_e, [["render", he]]), pe = {}, ve = { class: "m-h5" };
function be(e, t) {
  return n(), l("h5", ve, [
    o(e.$slots, "default")
  ]);
}
const ft = /* @__PURE__ */ _(pe, [["render", be]]), Me = {}, ye = { class: "m-h6" };
function ke(e, t) {
  return n(), l("h6", ye, [
    o(e.$slots, "default")
  ]);
}
const _t = /* @__PURE__ */ _(Me, [["render", ke]]), ge = ["type"], $t = /* @__PURE__ */ r({
  __name: "MInput",
  props: /* @__PURE__ */ O({
    block: { type: Boolean },
    error: { type: Boolean },
    transition: { type: Boolean },
    type: {}
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (u) => t.value = u),
      type: e.type || "text",
      class: c(["m-input", [
        { "--block": e.block },
        { "--error": e.error },
        { "--transition": e.transition }
      ]])
    }, null, 10, ge)), [
      [R, t.value]
    ]);
  }
}), ht = /* @__PURE__ */ r({
  __name: "MLabel",
  props: {
    required: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(e) {
    return (t, a) => (n(), l("label", {
      class: c(["m-label", [{ "--required": e.required, "--disabled": e.disabled }]])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), Be = {}, Ce = { class: "m-link" };
function Ve(e, t) {
  return n(), l("a", Ce, [
    o(e.$slots, "default")
  ]);
}
const pt = /* @__PURE__ */ _(Be, [["render", Ve]]), we = ({ getInsideElements: e, onClose: t }) => {
  const a = k(null), s = k([]);
  A(() => {
    a.value = document, s.value = e();
  });
  const u = (m, M) => {
    if (M)
      return setTimeout(() => {
        M.addEventListener("click", m);
      }, 0);
  }, $ = (m, M, V) => {
    V !== void 0 && clearTimeout(V), M?.removeEventListener("click", m);
  }, p = () => u(b, a.value), C = (m) => {
    $(b, a.value, m);
  };
  x(() => {
    C();
  });
  const v = (m, M) => {
    const V = m.target, H = (w, N) => w && !w.contains(N);
    M.every((w) => H(w, V)) && t();
  }, b = (m) => {
    v(m, s.value);
  };
  return {
    attachOutsideClickListener: p,
    detachOutsideClickListener: C
  };
}, Le = ["id"], vt = /* @__PURE__ */ r({
  __name: "MNavbar",
  props: {
    mobileMenuVariant: { default: null },
    closeOutsideClick: { type: Boolean, default: !1 },
    transition: { type: Boolean },
    id: { default: "m-navbar" }
  },
  setup(e) {
    const t = T("items"), a = T("hamburger"), s = k(!1), u = y(() => e.mobileMenuVariant !== null), $ = y(() => e.mobileMenuVariant ? {
      float: "--mobile-float-menu",
      side: "--mobile-side-menu",
      "side-left": "--mobile-side-menu --slide-left"
    }[e.mobileMenuVariant] : ""), { attachOutsideClickListener: p, detachOutsideClickListener: C } = we({
      // NOTE: It's unavoidable for $el to be any, so ignore
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      getInsideElements: () => [t.value?.$el, a.value?.$el].filter(Boolean),
      onClose: () => {
        s.value = !1;
      }
    });
    return E((v) => {
      if (!e.closeOutsideClick || !s.value || !e.mobileMenuVariant) return;
      const b = p();
      v(() => {
        C(b);
      });
    }), (v, b) => (n(), l("nav", {
      id: e.id,
      class: c(["m-navbar", [$.value, e.transition ? "--transition" : ""]])
    }, [
      o(v.$slots, "title"),
      I(i(Fe), { ref: "items" }, {
        default: d(() => [
          o(v.$slots, "items")
        ]),
        _: 3
      }, 512),
      o(v.$slots, "hamburger", {}, () => [
        u.value ? (n(), f(i(Ie), {
          key: 0,
          ref: "hamburger"
        }, {
          default: d(() => [
            I(i(He), {
              "show-menu": s.value,
              "aria-controls": e.id,
              onShowMenu: b[0] || (b[0] = (m) => s.value = m)
            }, null, 8, ["show-menu", "aria-controls"])
          ]),
          _: 1
        }, 512)) : h("", !0)
      ])
    ], 10, Le));
  }
}), Ae = {}, Oe = { class: "m-navbar__hamburger" };
function Te(e, t) {
  return n(), l("div", Oe, [
    o(e.$slots, "default")
  ]);
}
const Ie = /* @__PURE__ */ _(Ae, [["render", Te]]), Se = ["aria-label", "aria-expanded"], He = /* @__PURE__ */ r({
  __name: "MNavbarHamburgerMenu",
  props: {
    showMenu: { type: Boolean, default: !1 },
    closeLabel: { default: "Close menu" },
    openLabel: { default: "Open menu" }
  },
  emits: ["showMenu"],
  setup(e, { emit: t }) {
    const a = t, s = k(e.showMenu), u = y(() => s.value ? e.closeLabel : e.openLabel), $ = () => {
      s.value = !s.value, a("showMenu", s.value);
    };
    return L(() => e.showMenu, (p) => {
      s.value = p;
    }), (p, C) => (n(), l("button", {
      type: "button",
      class: "m-navbar__hamburger-menu",
      "aria-label": u.value,
      "aria-expanded": s.value,
      onClick: $
    }, null, 8, Se));
  }
}), Ne = ["href"], De = {
  key: 1,
  class: "m-navbar__title"
}, bt = /* @__PURE__ */ r({
  __name: "MNavbarTitle",
  props: {
    href: { default: () => {
    } }
  },
  setup(e) {
    const t = y(() => !!e.href);
    return (a, s) => t.value ? (n(), l("a", {
      key: 0,
      href: e.href,
      class: "m-navbar__title"
    }, [
      o(a.$slots, "default")
    ], 8, Ne)) : (n(), l("span", De, [
      o(a.$slots, "default")
    ]));
  }
}), Mt = /* @__PURE__ */ r({
  __name: "MNavbarItem",
  props: {
    end: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("li", {
      class: c(["m-navbar__item", { "--end": e.end }])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), Re = {}, xe = { class: "m-navbar__items" };
function Ee(e, t) {
  return n(), l("ul", xe, [
    o(e.$slots, "default")
  ]);
}
const Fe = /* @__PURE__ */ _(Re, [["render", Ee]]), Ue = {}, Pe = { class: "m-p" };
function qe(e, t) {
  return n(), l("p", Pe, [
    o(e.$slots, "default")
  ]);
}
const yt = /* @__PURE__ */ _(Ue, [["render", qe]]), kt = /* @__PURE__ */ r({
  __name: "MRadio",
  props: {
    modelValue: {},
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (u) => t.value = u),
      type: "radio",
      class: "m-radio"
    }, null, 512)), [
      [F, t.value]
    ]);
  }
}), gt = /* @__PURE__ */ r({
  __name: "MSelect",
  props: /* @__PURE__ */ O({
    error: { type: Boolean }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("select", {
      "onUpdate:modelValue": s[0] || (s[0] = (u) => t.value = u),
      class: c(["m-select", [
        { "--error": e.error }
      ]])
    }, [
      o(a.$slots, "default")
    ], 2)), [
      [U, t.value]
    ]);
  }
}), Bt = /* @__PURE__ */ r({
  __name: "MSnackbar",
  props: {
    open: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 },
    position: { default: null }
  },
  setup(e) {
    const t = k(null);
    return L(() => e.open, (a) => {
      t.value && (a ? t.value.showPopover() : t.value.hidePopover());
    }), A(() => {
      e.open && t.value && t.value.showPopover();
    }), (a, s) => (n(), l("div", {
      ref_key: "snackbarRef",
      ref: t,
      popover: "manual",
      class: c(["m-snackbar", [
        { "--transition": e.transition },
        e.position ? `--${e.position}` : ""
      ]])
    }, [
      a.$slots.default ? (n(), f(i(We), { key: 0 }, {
        default: d(() => [
          o(a.$slots, "default"),
          a.$slots.actions ? (n(), f(i(je), { key: 0 }, {
            default: d(() => [
              o(a.$slots, "actions")
            ]),
            _: 3
          })) : h("", !0)
        ]),
        _: 3
      })) : h("", !0)
    ], 2));
  }
}), Ge = { class: "m-snackbar__actions" }, je = /* @__PURE__ */ r({
  __name: "MSnackbarActions",
  setup(e) {
    return (t, a) => (n(), l("div", Ge, [
      o(t.$slots, "default")
    ]));
  }
}), ze = { class: "m-snackbar__body" }, We = /* @__PURE__ */ r({
  __name: "MSnackbarBody",
  setup(e) {
    return (t, a) => (n(), l("div", ze, [
      o(t.$slots, "default")
    ]));
  }
}), Ct = /* @__PURE__ */ r({
  __name: "MTabs",
  props: {
    transition: { type: Boolean },
    scrollhint: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (a, s) => (n(), l("div", {
      class: c(["m-tabs", [
        { "--transition": t.transition },
        { "--scrollhint": t.scrollhint }
      ]])
    }, [
      o(a.$slots, "default")
    ], 2));
  }
}), Je = {}, Ke = {
  class: "m-tabs__list",
  role: "tablist"
};
function Qe(e, t) {
  return n(), l("div", Ke, [
    o(e.$slots, "default")
  ]);
}
const Vt = /* @__PURE__ */ _(Je, [["render", Qe]]), Xe = ["aria-selected", "tabindex"], wt = /* @__PURE__ */ r({
  __name: "MTabsItem",
  props: {
    active: { type: Boolean, default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = t, s = (u) => {
      a("click", u);
    };
    return (u, $) => (n(), l("button", {
      type: "button",
      class: c(["m-tabs__item", [{ "--active": e.active }]]),
      role: "tab",
      "aria-selected": e.active ? "true" : "false",
      tabindex: e.active ? "0" : "-1",
      onClick: s
    }, [
      o(u.$slots, "default")
    ], 10, Xe));
  }
}), Lt = /* @__PURE__ */ r({
  __name: "MTable",
  props: {
    stripe: { type: Boolean, default: !1 },
    bordered: { type: Boolean, default: !1 },
    hoverable: { type: Boolean, default: !1 },
    fullWidth: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("table", {
      class: c(["m-table", [
        { "--stripe": e.stripe },
        { "--bordered": e.bordered },
        { "--hoverable": e.hoverable },
        { "--full-width": e.fullWidth },
        { "--transition": e.transition }
      ]])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), At = /* @__PURE__ */ r({
  __name: "MTextarea",
  props: /* @__PURE__ */ O({
    block: { type: Boolean },
    error: { type: Boolean },
    autoFit: { type: Boolean }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (u) => t.value = u),
      class: c(["m-textarea", [
        { "--block": e.block },
        { "--error": e.error },
        { "--auto-fit": e.autoFit }
      ]])
    }, null, 2)), [
      [P, t.value]
    ]);
  }
}), Ot = /* @__PURE__ */ r({
  __name: "MToggle",
  props: {
    modelValue: { type: Boolean },
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (u) => t.value = u),
      type: "checkbox",
      class: "m-toggle"
    }, null, 512)), [
      [S, t.value]
    ]);
  }
}), Ye = ["data-columns-length"], Tt = /* @__PURE__ */ r({
  __name: "MColumns",
  props: {
    columnsLength: { default: null },
    autoFit: { type: Boolean, default: !1 },
    noGap: { type: Boolean, default: !1 },
    alignRows: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("div", {
      class: c(["m-columns", [
        { "--auto-fit": e.autoFit },
        { "--no-gap": e.noGap },
        { "--align-rows": e.alignRows }
      ]]),
      "data-columns-length": e.columnsLength
    }, [
      o(t.$slots, "default")
    ], 10, Ye));
  }
}), It = /* @__PURE__ */ r({
  __name: "MContainer",
  props: {
    padding: { type: Boolean },
    noCentering: { type: Boolean }
  },
  setup(e) {
    const t = y(() => ({
      "--padding": e.padding,
      "--no-centering": e.noCentering
    }));
    return (a, s) => (n(), l("div", {
      class: c(["m-container", t.value])
    }, [
      o(a.$slots, "default")
    ], 2));
  }
});
export {
  tt as MAccordion,
  z as MAccordionContent,
  G as MAccordionSummary,
  at as MAlert,
  K as MAlertActions,
  X as MAlertContent,
  Z as MAlertIcons,
  nt as MBadge,
  st as MBtn,
  ot as MCard,
  ne as MCardContent,
  te as MCardFooter,
  lt as MCardImage,
  rt as MCheckbox,
  Tt as MColumns,
  It as MContainer,
  ut as MDialog,
  ct as MH1,
  it as MH2,
  dt as MH3,
  mt as MH4,
  ft as MH5,
  _t as MH6,
  $t as MInput,
  ht as MLabel,
  pt as MLink,
  vt as MNavbar,
  Ie as MNavbarHamburger,
  He as MNavbarHamburgerMenu,
  Mt as MNavbarItem,
  Fe as MNavbarItems,
  bt as MNavbarTitle,
  yt as MP,
  kt as MRadio,
  gt as MSelect,
  Bt as MSnackbar,
  je as MSnackbarActions,
  We as MSnackbarBody,
  Lt as MTable,
  Ct as MTabs,
  wt as MTabsItem,
  Vt as MTabsList,
  At as MTextarea,
  Ot as MToggle
};
