import { defineComponent as r, createElementBlock as o, openBlock as a, normalizeClass as u, createBlock as i, createCommentVNode as _, unref as d, withCtx as m, renderSlot as s, computed as p, resolveDynamicComponent as V, useModel as h, withDirectives as M, vModelCheckbox as y, ref as b, watch as k, onMounted as g, mergeModels as v, vModelDynamic as C, createElementVNode as A, createVNode as w, vModelRadio as L, vModelSelect as N, vModelText as S } from "vue";
const Ue = /* @__PURE__ */ r({
  __name: "MAccordion",
  props: {
    transition: { type: Boolean, default: !1 },
    outline: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (a(), o("details", {
      class: u(["m-accordion", [
        { "--transition": e.transition },
        { "--outline": e.outline }
      ]])
    }, [
      t.$slots.summary ? (a(), i(d(H), { key: 0 }, {
        default: m(() => [
          s(t.$slots, "summary")
        ]),
        _: 3
      })) : _("", !0),
      t.$slots.default ? (a(), i(d(x), { key: 1 }, {
        default: m(() => [
          s(t.$slots, "default")
        ]),
        _: 3
      })) : _("", !0)
    ], 2));
  }
}), T = { class: "m-accordion__summary" }, H = /* @__PURE__ */ r({
  __name: "MAccordionSummary",
  setup(e) {
    return (t, n) => (a(), o("summary", T, [
      s(t.$slots, "default")
    ]));
  }
}), I = { class: "m-accordion__content" }, x = /* @__PURE__ */ r({
  __name: "MAccordionContent",
  setup(e) {
    return (t, n) => (a(), o("div", I, [
      s(t.$slots, "default")
    ]));
  }
}), R = ["data-auto-dismiss"], qe = /* @__PURE__ */ r({
  __name: "MAlert",
  props: {
    variant: { default: null },
    withProgress: { type: Boolean, default: !1 },
    autoDismiss: { default: null }
  },
  setup(e) {
    return (t, n) => (a(), o("div", {
      class: u(["m-alert", [
        e.variant ? `--${e.variant}` : "",
        { "--with-progress": e.withProgress }
      ]]),
      role: "alert",
      "data-auto-dismiss": e.autoDismiss
    }, [
      t.$slots.icons ? (a(), i(d(F), { key: 0 }, {
        default: m(() => [
          s(t.$slots, "icons")
        ]),
        _: 3
      })) : _("", !0),
      t.$slots.default ? (a(), i(d(U), { key: 1 }, {
        default: m(() => [
          s(t.$slots, "default")
        ]),
        _: 3
      })) : _("", !0),
      t.$slots.actions ? (a(), i(d(O), { key: 2 }, {
        default: m(() => [
          s(t.$slots, "actions")
        ]),
        _: 3
      })) : _("", !0)
    ], 10, R));
  }
}), D = { class: "m-alert__actions" }, O = /* @__PURE__ */ r({
  __name: "MAlertActions",
  setup(e) {
    return (t, n) => (a(), o("div", D, [
      s(t.$slots, "default")
    ]));
  }
}), P = { class: "m-alert__content" }, U = /* @__PURE__ */ r({
  __name: "MAlertContent",
  setup(e) {
    return (t, n) => (a(), o("div", P, [
      s(t.$slots, "default")
    ]));
  }
}), q = { class: "m-alert__icons" }, F = /* @__PURE__ */ r({
  __name: "MAlertIcons",
  setup(e) {
    return (t, n) => (a(), o("div", q, [
      s(t.$slots, "default")
    ]));
  }
}), Fe = /* @__PURE__ */ r({
  __name: "MBadge",
  props: {
    as: { default: "span" },
    variant: { default: null },
    outline: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = p(() => [
      "m-badge",
      e.variant ? `--${e.variant}` : "",
      { "--outline": e.outline },
      { "--small": e.small },
      { "--rounded": e.rounded },
      { "--transition": e.transition }
    ]);
    return (n, l) => (a(), i(V(e.as), {
      class: u(t.value)
    }, {
      default: m(() => [
        s(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ee = /* @__PURE__ */ r({
  __name: "MBtn",
  props: {
    variant: { default: null },
    outline: { type: Boolean, default: !1 },
    block: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    iconOnly: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (a(), o("button", {
      class: u(["m-btn", [
        e.variant ? `--${e.variant}` : "",
        { "--outline": e.outline },
        { "--block": e.block },
        { "--rounded": e.rounded },
        { "--icon-only": e.iconOnly },
        { "--transition": e.transition }
      ]])
    }, [
      s(t.$slots, "default")
    ], 2));
  }
}), je = /* @__PURE__ */ r({
  __name: "MCard",
  props: {
    floating: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (a(), o("div", {
      class: u(["m-card", [
        { "--floating": e.floating }
      ]])
    }, [
      s(t.$slots, "image"),
      t.$slots.default ? (a(), i(d(G), { key: 0 }, {
        default: m(() => [
          s(t.$slots, "default")
        ]),
        _: 3
      })) : _("", !0),
      t.$slots.actions ? (a(), i(d(j), { key: 1 }, {
        default: m(() => [
          s(t.$slots, "actions")
        ]),
        _: 3
      })) : _("", !0)
    ], 2));
  }
}), E = { class: "m-card__actions" }, j = /* @__PURE__ */ r({
  __name: "MCardActions",
  setup(e) {
    return (t, n) => (a(), o("div", E, [
      s(t.$slots, "default")
    ]));
  }
}), z = { class: "m-card__content" }, G = /* @__PURE__ */ r({
  __name: "MCardContent",
  setup(e) {
    return (t, n) => (a(), o("div", z, [
      s(t.$slots, "default")
    ]));
  }
}), J = ["src", "alt"], ze = /* @__PURE__ */ r({
  __name: "MCardImage",
  props: {
    src: {},
    alt: {}
  },
  setup(e) {
    return (t, n) => (a(), o("img", {
      class: "m-card__image",
      src: e.src,
      alt: e.alt
    }, null, 8, J));
  }
}), Ge = /* @__PURE__ */ r({
  __name: "MCheckbox",
  props: {
    modelValue: { type: Boolean },
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = h(e, "modelValue");
    return (n, l) => M((a(), o("input", {
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      type: "checkbox",
      class: "m-checkbox"
    }, null, 512)), [
      [y, t.value]
    ]);
  }
}), Je = /* @__PURE__ */ r({
  __name: "MDialog",
  props: {
    open: { type: Boolean, default: !1 },
    backdropBlur: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    const n = t, l = b(null);
    k(() => e.open, ($) => {
      l.value && ($ ? l.value.showModal() : l.value.close());
    });
    const c = () => {
      n("close");
    };
    return g(() => {
      e.open && l.value && l.value.showModal();
    }), ($, B) => (a(), o("dialog", {
      ref_key: "dialogRef",
      ref: l,
      class: u(["m-dialog", [
        { "--backdrop-blur": e.backdropBlur },
        { "--transition": e.transition }
      ]]),
      onClose: c
    }, [
      s($.$slots, "default")
    ], 34));
  }
}), f = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [l, c] of t)
    n[l] = c;
  return n;
}, K = {}, Q = { class: "m-h1" };
function W(e, t) {
  return a(), o("h1", Q, [
    s(e.$slots, "default")
  ]);
}
const Ke = /* @__PURE__ */ f(K, [["render", W]]), X = {}, Y = { class: "m-h2" };
function Z(e, t) {
  return a(), o("h2", Y, [
    s(e.$slots, "default")
  ]);
}
const Qe = /* @__PURE__ */ f(X, [["render", Z]]), ee = {}, te = { class: "m-h3" };
function ae(e, t) {
  return a(), o("h3", te, [
    s(e.$slots, "default")
  ]);
}
const We = /* @__PURE__ */ f(ee, [["render", ae]]), ne = {}, se = { class: "m-h4" };
function oe(e, t) {
  return a(), o("h4", se, [
    s(e.$slots, "default")
  ]);
}
const Xe = /* @__PURE__ */ f(ne, [["render", oe]]), le = {}, re = { class: "m-h5" };
function ce(e, t) {
  return a(), o("h5", re, [
    s(e.$slots, "default")
  ]);
}
const Ye = /* @__PURE__ */ f(le, [["render", ce]]), ue = {}, ie = { class: "m-h6" };
function de(e, t) {
  return a(), o("h6", ie, [
    s(e.$slots, "default")
  ]);
}
const Ze = /* @__PURE__ */ f(ue, [["render", de]]), me = ["type"], et = /* @__PURE__ */ r({
  __name: "MInput",
  props: /* @__PURE__ */ v({
    block: { type: Boolean },
    error: { type: Boolean },
    transition: { type: Boolean },
    type: {}
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = h(e, "modelValue");
    return (n, l) => M((a(), o("input", {
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      type: e.type || "text",
      class: u(["m-input", [
        { "--block": e.block },
        { "--error": e.error },
        { "--transition": e.transition }
      ]])
    }, null, 10, me)), [
      [C, t.value]
    ]);
  }
}), tt = /* @__PURE__ */ r({
  __name: "MLabel",
  props: {
    required: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(e) {
    return (t, n) => (a(), o("label", {
      class: u(["m-label", [{ "--required": e.required, "--disabled": e.disabled }]])
    }, [
      s(t.$slots, "default")
    ], 2));
  }
}), _e = {}, fe = { class: "m-link" };
function $e(e, t) {
  return a(), o("a", fe, [
    s(e.$slots, "default")
  ]);
}
const at = /* @__PURE__ */ f(_e, [["render", $e]]), pe = ["id"], he = { class: "m-navbar__items" }, nt = /* @__PURE__ */ r({
  __name: "MNavbar",
  props: {
    mobileMenuVariant: { default: null },
    transition: { type: Boolean },
    id: { default: "m-navbar" }
  },
  setup(e) {
    const t = b(!1), n = p(() => e.mobileMenuVariant !== null), l = p(() => e.mobileMenuVariant ? {
      float: "--mobile-float-menu",
      side: "--mobile-side-menu",
      "side-left": "--mobile-side-menu --slide-left"
    }[e.mobileMenuVariant] : "");
    return (c, $) => (a(), o("nav", {
      id: e.id,
      class: u(["m-navbar", [l.value, e.transition ? "--transition" : ""]])
    }, [
      s(c.$slots, "title"),
      A("ul", he, [
        s(c.$slots, "items")
      ]),
      s(c.$slots, "hamburger", {}, () => [
        n.value ? (a(), i(d(ye), { key: 0 }, {
          default: m(() => [
            w(d(ge), {
              "show-menu": t.value,
              "aria-controls": e.id
            }, null, 8, ["show-menu", "aria-controls"])
          ]),
          _: 1
        })) : _("", !0)
      ])
    ], 10, pe));
  }
}), Me = {}, be = { class: "m-navbar__hamburger" };
function ve(e, t) {
  return a(), o("div", be, [
    s(e.$slots, "default")
  ]);
}
const ye = /* @__PURE__ */ f(Me, [["render", ve]]), ke = ["aria-label", "aria-expanded"], ge = /* @__PURE__ */ r({
  __name: "MNavbarHamburgerMenu",
  props: {
    showMenu: { type: Boolean, default: !1 },
    closeLabel: { default: "Close menu" },
    openLabel: { default: "Open menu" }
  },
  emits: ["showMenu"],
  setup(e, { emit: t }) {
    const n = t, l = b(e.showMenu), c = p(() => l.value ? e.closeLabel : e.openLabel), $ = () => {
      l.value = !l.value, n("showMenu", l.value);
    };
    return (B, Oe) => (a(), o("button", {
      type: "button",
      class: "m-navbar__hamburger-menu",
      "aria-label": c.value,
      "aria-expanded": l.value,
      onClick: $
    }, null, 8, ke));
  }
}), Be = ["href"], Ve = {
  key: 1,
  class: "m-navbar__title"
}, st = /* @__PURE__ */ r({
  __name: "MNavbarTitle",
  props: {
    href: { default: () => {
    } }
  },
  setup(e) {
    const t = p(() => !!e.href);
    return (n, l) => t.value ? (a(), o("a", {
      key: 0,
      href: e.href,
      class: "m-navbar__title"
    }, [
      s(n.$slots, "default")
    ], 8, Be)) : (a(), o("span", Ve, [
      s(n.$slots, "default")
    ]));
  }
}), ot = /* @__PURE__ */ r({
  __name: "MNavbarItem",
  props: {
    end: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (a(), o("li", {
      class: u(["m-navbar__item", { "--end": e.end }])
    }, [
      s(t.$slots, "default")
    ], 2));
  }
}), Ce = {}, Ae = { class: "m-p" };
function we(e, t) {
  return a(), o("p", Ae, [
    s(e.$slots, "default")
  ]);
}
const lt = /* @__PURE__ */ f(Ce, [["render", we]]), rt = /* @__PURE__ */ r({
  __name: "MRadio",
  props: {
    modelValue: {},
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = h(e, "modelValue");
    return (n, l) => M((a(), o("input", {
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      type: "radio",
      class: "m-radio"
    }, null, 512)), [
      [L, t.value]
    ]);
  }
}), ct = /* @__PURE__ */ r({
  __name: "MSelect",
  props: /* @__PURE__ */ v({
    error: { type: Boolean }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = h(e, "modelValue");
    return (n, l) => M((a(), o("select", {
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      class: u(["m-select", [
        { "--error": e.error }
      ]])
    }, [
      s(n.$slots, "default")
    ], 2)), [
      [N, t.value]
    ]);
  }
}), ut = /* @__PURE__ */ r({
  __name: "MSnackbar",
  props: {
    open: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 },
    position: { default: null }
  },
  setup(e) {
    const t = b(null);
    return k(() => e.open, (n) => {
      t.value && (n ? t.value.showPopover() : t.value.hidePopover());
    }), g(() => {
      e.open && t.value && t.value.showPopover();
    }), (n, l) => (a(), o("div", {
      ref_key: "snackbarRef",
      ref: t,
      popover: "manual",
      class: u(["m-snackbar", [
        { "--transition": e.transition },
        e.position ? `--${e.position}` : ""
      ]])
    }, [
      n.$slots.default ? (a(), i(d(Te), { key: 0 }, {
        default: m(() => [
          s(n.$slots, "default")
        ]),
        _: 3
      })) : _("", !0),
      n.$slots.actions ? (a(), i(d(Ne), { key: 1 }, {
        default: m(() => [
          s(n.$slots, "actions")
        ]),
        _: 3
      })) : _("", !0)
    ], 2));
  }
}), Le = { class: "m-snackbar__actions" }, Ne = /* @__PURE__ */ r({
  __name: "MSnackbarActions",
  setup(e) {
    return (t, n) => (a(), o("div", Le, [
      s(t.$slots, "default")
    ]));
  }
}), Se = { class: "m-snackbar__body" }, Te = /* @__PURE__ */ r({
  __name: "MSnackbarBody",
  setup(e) {
    return (t, n) => (a(), o("div", Se, [
      s(t.$slots, "default")
    ]));
  }
}), it = /* @__PURE__ */ r({
  __name: "MTabs",
  props: {
    transition: { type: Boolean },
    scrollhint: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, l) => (a(), o("div", {
      class: u(["m-tabs", [
        { "--transition": t.transition },
        { "--scrollhint": t.scrollhint }
      ]])
    }, [
      s(n.$slots, "default")
    ], 2));
  }
}), He = {}, Ie = {
  class: "m-tabs__list",
  role: "tablist"
};
function xe(e, t) {
  return a(), o("div", Ie, [
    s(e.$slots, "default")
  ]);
}
const dt = /* @__PURE__ */ f(He, [["render", xe]]), Re = ["aria-selected", "tabindex"], mt = /* @__PURE__ */ r({
  __name: "MTabsItem",
  props: {
    active: { type: Boolean, default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const n = t, l = (c) => {
      n("click", c);
    };
    return (c, $) => (a(), o("button", {
      type: "button",
      class: u(["m-tabs__item", [{ "--active": e.active }]]),
      role: "tab",
      "aria-selected": e.active ? "true" : "false",
      tabindex: e.active ? "0" : "-1",
      onClick: l
    }, [
      s(c.$slots, "default")
    ], 10, Re));
  }
}), _t = /* @__PURE__ */ r({
  __name: "MTextarea",
  props: /* @__PURE__ */ v({
    block: { type: Boolean },
    error: { type: Boolean },
    autoFit: { type: Boolean }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = h(e, "modelValue");
    return (n, l) => M((a(), o("textarea", {
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      class: u(["m-textarea", [
        { "--block": e.block },
        { "--error": e.error },
        { "--auto-fit": e.autoFit }
      ]])
    }, null, 2)), [
      [S, t.value]
    ]);
  }
}), ft = /* @__PURE__ */ r({
  __name: "MToggle",
  props: {
    modelValue: { type: Boolean },
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = h(e, "modelValue");
    return (n, l) => M((a(), o("input", {
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      type: "checkbox",
      class: "m-toggle"
    }, null, 512)), [
      [y, t.value]
    ]);
  }
}), De = ["data-columns-length"], $t = /* @__PURE__ */ r({
  __name: "MColumns",
  props: {
    columnsLength: { default: null },
    autoFit: { type: Boolean, default: !1 },
    noGap: { type: Boolean, default: !1 },
    alignRows: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (a(), o("div", {
      class: u(["m-columns", [
        { "--auto-fit": e.autoFit },
        { "--no-gap": e.noGap },
        { "--align-rows": e.alignRows }
      ]]),
      "data-columns-length": e.columnsLength
    }, [
      s(t.$slots, "default")
    ], 10, De));
  }
}), pt = /* @__PURE__ */ r({
  __name: "MContainer",
  props: {
    padding: { type: Boolean },
    noCentering: { type: Boolean }
  },
  setup(e) {
    const t = p(() => ({
      "--padding": e.padding,
      "--no-centering": e.noCentering
    }));
    return (n, l) => (a(), o("div", {
      class: u(["m-container", t.value])
    }, [
      s(n.$slots, "default")
    ], 2));
  }
});
export {
  Ue as MAccordion,
  x as MAccordionContent,
  H as MAccordionSummary,
  qe as MAlert,
  O as MAlertActions,
  U as MAlertContent,
  F as MAlertIcons,
  Fe as MBadge,
  Ee as MBtn,
  je as MCard,
  j as MCardActions,
  G as MCardContent,
  ze as MCardImage,
  Ge as MCheckbox,
  $t as MColumns,
  pt as MContainer,
  Je as MDialog,
  Ke as MH1,
  Qe as MH2,
  We as MH3,
  Xe as MH4,
  Ye as MH5,
  Ze as MH6,
  et as MInput,
  tt as MLabel,
  at as MLink,
  nt as MNavbar,
  ye as MNavbarHamburger,
  ge as MNavbarHamburgerMenu,
  ot as MNavbarItem,
  st as MNavbarTitle,
  lt as MP,
  rt as MRadio,
  ct as MSelect,
  ut as MSnackbar,
  Ne as MSnackbarActions,
  Te as MSnackbarBody,
  it as MTabs,
  mt as MTabsItem,
  dt as MTabsList,
  _t as MTextarea,
  ft as MToggle
};
