import { defineComponent as r, createElementBlock as l, openBlock as n, normalizeClass as u, createBlock as f, createCommentVNode as h, unref as i, withCtx as d, renderSlot as o, computed as y, resolveDynamicComponent as H, useModel as g, withDirectives as B, vModelCheckbox as S, ref as k, watch as A, onMounted as L, mergeModels as O, vModelDynamic as R, onUnmounted as x, useTemplateRef as T, watchEffect as E, createVNode as I, vModelRadio as U, vModelSelect as P, vModelText as q } from "vue";
const tt = /* @__PURE__ */ r({
  __name: "MAccordion",
  props: {
    transition: { type: Boolean, default: !1 },
    outline: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("details", {
      class: u(["m-accordion", [
        { "--transition": e.transition },
        { "--outline": e.outline }
      ]])
    }, [
      t.$slots.summary ? (n(), f(i(G), { key: 0 }, {
        default: d(() => [
          o(t.$slots, "summary")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.default ? (n(), f(i(z), { key: 1 }, {
        default: d(() => [
          o(t.$slots, "default")
        ]),
        _: 3
      })) : h("", !0)
    ], 2));
  }
}), F = { class: "m-accordion__summary" }, G = /* @__PURE__ */ r({
  __name: "MAccordionSummary",
  setup(e) {
    return (t, a) => (n(), l("summary", F, [
      o(t.$slots, "default")
    ]));
  }
}), j = { class: "m-accordion__content" }, z = /* @__PURE__ */ r({
  __name: "MAccordionContent",
  setup(e) {
    return (t, a) => (n(), l("div", j, [
      o(t.$slots, "default")
    ]));
  }
}), J = ["data-auto-dismiss"], at = /* @__PURE__ */ r({
  __name: "MAlert",
  props: {
    variant: { default: null },
    withProgress: { type: Boolean, default: !1 },
    autoDismiss: { default: null }
  },
  setup(e) {
    return (t, a) => (n(), l("div", {
      class: u(["m-alert", [
        e.variant ? `--${e.variant}` : "",
        { "--with-progress": e.withProgress }
      ]]),
      role: "alert",
      "data-auto-dismiss": e.autoDismiss
    }, [
      t.$slots.icons ? (n(), f(i(Z), { key: 0 }, {
        default: d(() => [
          o(t.$slots, "icons")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.default ? (n(), f(i(X), { key: 1 }, {
        default: d(() => [
          o(t.$slots, "default")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.actions ? (n(), f(i(Q), { key: 2 }, {
        default: d(() => [
          o(t.$slots, "actions")
        ]),
        _: 3
      })) : h("", !0)
    ], 10, J));
  }
}), K = { class: "m-alert__actions" }, Q = /* @__PURE__ */ r({
  __name: "MAlertActions",
  setup(e) {
    return (t, a) => (n(), l("div", K, [
      o(t.$slots, "default")
    ]));
  }
}), W = { class: "m-alert__content" }, X = /* @__PURE__ */ r({
  __name: "MAlertContent",
  setup(e) {
    return (t, a) => (n(), l("div", W, [
      o(t.$slots, "default")
    ]));
  }
}), Y = { class: "m-alert__icons" }, Z = /* @__PURE__ */ r({
  __name: "MAlertIcons",
  setup(e) {
    return (t, a) => (n(), l("div", Y, [
      o(t.$slots, "default")
    ]));
  }
}), nt = /* @__PURE__ */ r({
  __name: "MBadge",
  props: {
    as: { default: "span" },
    variant: { default: null },
    outline: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = y(() => [
      "m-badge",
      e.variant ? `--${e.variant}` : "",
      { "--outline": e.outline },
      { "--small": e.small },
      { "--rounded": e.rounded },
      { "--transition": e.transition }
    ]);
    return (a, s) => (n(), f(H(e.as), {
      class: u(t.value)
    }, {
      default: d(() => [
        o(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), st = /* @__PURE__ */ r({
  __name: "MBtn",
  props: {
    variant: { default: null },
    outline: { type: Boolean, default: !1 },
    block: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    iconOnly: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("button", {
      class: u(["m-btn", [
        e.variant ? `--${e.variant}` : "",
        { "--outline": e.outline },
        { "--block": e.block },
        { "--rounded": e.rounded },
        { "--icon-only": e.iconOnly },
        { "--transition": e.transition }
      ]])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), ot = /* @__PURE__ */ r({
  __name: "MCard",
  props: {
    floating: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("div", {
      class: u(["m-card", [
        { "--floating": e.floating }
      ]])
    }, [
      o(t.$slots, "image"),
      t.$slots.default ? (n(), f(i(ne), { key: 0 }, {
        default: d(() => [
          o(t.$slots, "default")
        ]),
        _: 3
      })) : h("", !0),
      t.$slots.actions ? (n(), f(i(te), { key: 1 }, {
        default: d(() => [
          o(t.$slots, "actions")
        ]),
        _: 3
      })) : h("", !0)
    ], 2));
  }
}), ee = { class: "m-card__actions" }, te = /* @__PURE__ */ r({
  __name: "MCardActions",
  setup(e) {
    return (t, a) => (n(), l("div", ee, [
      o(t.$slots, "default")
    ]));
  }
}), ae = { class: "m-card__content" }, ne = /* @__PURE__ */ r({
  __name: "MCardContent",
  setup(e) {
    return (t, a) => (n(), l("div", ae, [
      o(t.$slots, "default")
    ]));
  }
}), se = ["src", "alt"], lt = /* @__PURE__ */ r({
  __name: "MCardImage",
  props: {
    src: {},
    alt: {}
  },
  setup(e) {
    return (t, a) => (n(), l("img", {
      class: "m-card__image",
      src: e.src,
      alt: e.alt
    }, null, 8, se));
  }
}), rt = /* @__PURE__ */ r({
  __name: "MCheckbox",
  props: {
    modelValue: { type: Boolean },
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (c) => t.value = c),
      type: "checkbox",
      class: "m-checkbox"
    }, null, 512)), [
      [S, t.value]
    ]);
  }
}), ct = /* @__PURE__ */ r({
  __name: "MDialog",
  props: {
    open: { type: Boolean, default: !1 },
    backdropBlur: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 }
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    const a = t, s = k(null);
    A(() => e.open, ($) => {
      s.value && ($ ? s.value.showModal() : s.value.close());
    });
    const c = () => {
      a("close");
    };
    return L(() => {
      e.open && s.value && s.value.showModal();
    }), ($, p) => (n(), l("dialog", {
      ref_key: "dialogRef",
      ref: s,
      class: u(["m-dialog", [
        { "--backdrop-blur": e.backdropBlur },
        { "--transition": e.transition }
      ]]),
      onClose: c
    }, [
      o($.$slots, "default")
    ], 34));
  }
}), _ = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [s, c] of t)
    a[s] = c;
  return a;
}, oe = {}, le = { class: "m-h1" };
function re(e, t) {
  return n(), l("h1", le, [
    o(e.$slots, "default")
  ]);
}
const ut = /* @__PURE__ */ _(oe, [["render", re]]), ce = {}, ue = { class: "m-h2" };
function ie(e, t) {
  return n(), l("h2", ue, [
    o(e.$slots, "default")
  ]);
}
const it = /* @__PURE__ */ _(ce, [["render", ie]]), de = {}, me = { class: "m-h3" };
function fe(e, t) {
  return n(), l("h3", me, [
    o(e.$slots, "default")
  ]);
}
const dt = /* @__PURE__ */ _(de, [["render", fe]]), _e = {}, $e = { class: "m-h4" };
function he(e, t) {
  return n(), l("h4", $e, [
    o(e.$slots, "default")
  ]);
}
const mt = /* @__PURE__ */ _(_e, [["render", he]]), pe = {}, ve = { class: "m-h5" };
function Me(e, t) {
  return n(), l("h5", ve, [
    o(e.$slots, "default")
  ]);
}
const ft = /* @__PURE__ */ _(pe, [["render", Me]]), be = {}, ye = { class: "m-h6" };
function ke(e, t) {
  return n(), l("h6", ye, [
    o(e.$slots, "default")
  ]);
}
const _t = /* @__PURE__ */ _(be, [["render", ke]]), ge = ["type"], $t = /* @__PURE__ */ r({
  __name: "MInput",
  props: /* @__PURE__ */ O({
    block: { type: Boolean },
    error: { type: Boolean },
    transition: { type: Boolean },
    type: {}
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (c) => t.value = c),
      type: e.type || "text",
      class: u(["m-input", [
        { "--block": e.block },
        { "--error": e.error },
        { "--transition": e.transition }
      ]])
    }, null, 10, ge)), [
      [R, t.value]
    ]);
  }
}), ht = /* @__PURE__ */ r({
  __name: "MLabel",
  props: {
    required: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(e) {
    return (t, a) => (n(), l("label", {
      class: u(["m-label", [{ "--required": e.required, "--disabled": e.disabled }]])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), Be = {}, Ce = { class: "m-link" };
function Ve(e, t) {
  return n(), l("a", Ce, [
    o(e.$slots, "default")
  ]);
}
const pt = /* @__PURE__ */ _(Be, [["render", Ve]]), we = ({ getInsideElements: e, onClose: t }) => {
  const a = k(null), s = k([]);
  L(() => {
    a.value = document, s.value = e();
  });
  const c = (m, b) => {
    if (b)
      return setTimeout(() => {
        b.addEventListener("click", m);
      }, 0);
  }, $ = (m, b, V) => {
    V !== void 0 && clearTimeout(V), b?.removeEventListener("click", m);
  }, p = () => c(M, a.value), C = (m) => {
    $(M, a.value, m);
  };
  x(() => {
    C();
  });
  const v = (m, b) => {
    const V = m.target, N = (w, D) => w && !w.contains(D);
    b.every((w) => N(w, V)) && t();
  }, M = (m) => {
    v(m, s.value);
  };
  return {
    attachOutsideClickListener: p,
    detachOutsideClickListener: C
  };
}, Ae = ["id"], vt = /* @__PURE__ */ r({
  __name: "MNavbar",
  props: {
    mobileMenuVariant: { default: null },
    closeOutsideClick: { type: Boolean, default: !1 },
    transition: { type: Boolean },
    id: { default: "m-navbar" }
  },
  setup(e) {
    const t = T("items"), a = T("hamburger"), s = k(!1), c = y(() => e.mobileMenuVariant !== null), $ = y(() => e.mobileMenuVariant ? {
      float: "--mobile-float-menu",
      side: "--mobile-side-menu",
      "side-left": "--mobile-side-menu --slide-left"
    }[e.mobileMenuVariant] : ""), { attachOutsideClickListener: p, detachOutsideClickListener: C } = we({
      // NOTE: It's unavoidable for $el to be any, so ignore
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      getInsideElements: () => [t.value?.$el, a.value?.$el].filter(Boolean),
      onClose: () => {
        s.value = !1;
      }
    });
    return E((v) => {
      if (!e.closeOutsideClick || !s.value || !e.mobileMenuVariant) return;
      const M = p();
      v(() => {
        C(M);
      });
    }), (v, M) => (n(), l("nav", {
      id: e.id,
      class: u(["m-navbar", [$.value, e.transition ? "--transition" : ""]])
    }, [
      o(v.$slots, "title"),
      I(i(Ue), { ref: "items" }, {
        default: d(() => [
          o(v.$slots, "items")
        ]),
        _: 3
      }, 512),
      o(v.$slots, "hamburger", {}, () => [
        c.value ? (n(), f(i(Ie), {
          key: 0,
          ref: "hamburger"
        }, {
          default: d(() => [
            I(i(Ne), {
              "show-menu": s.value,
              "aria-controls": e.id,
              onShowMenu: M[0] || (M[0] = (m) => s.value = m)
            }, null, 8, ["show-menu", "aria-controls"])
          ]),
          _: 1
        }, 512)) : h("", !0)
      ])
    ], 10, Ae));
  }
}), Le = {}, Oe = { class: "m-navbar__hamburger" };
function Te(e, t) {
  return n(), l("div", Oe, [
    o(e.$slots, "default")
  ]);
}
const Ie = /* @__PURE__ */ _(Le, [["render", Te]]), Se = ["aria-label", "aria-expanded"], Ne = /* @__PURE__ */ r({
  __name: "MNavbarHamburgerMenu",
  props: {
    showMenu: { type: Boolean, default: !1 },
    closeLabel: { default: "Close menu" },
    openLabel: { default: "Open menu" }
  },
  emits: ["showMenu"],
  setup(e, { emit: t }) {
    const a = t, s = k(e.showMenu), c = y(() => s.value ? e.closeLabel : e.openLabel), $ = () => {
      s.value = !s.value, a("showMenu", s.value);
    };
    return A(() => e.showMenu, (p) => {
      s.value = p;
    }), (p, C) => (n(), l("button", {
      type: "button",
      class: "m-navbar__hamburger-menu",
      "aria-label": c.value,
      "aria-expanded": s.value,
      onClick: $
    }, null, 8, Se));
  }
}), De = ["href"], He = {
  key: 1,
  class: "m-navbar__title"
}, Mt = /* @__PURE__ */ r({
  __name: "MNavbarTitle",
  props: {
    href: { default: () => {
    } }
  },
  setup(e) {
    const t = y(() => !!e.href);
    return (a, s) => t.value ? (n(), l("a", {
      key: 0,
      href: e.href,
      class: "m-navbar__title"
    }, [
      o(a.$slots, "default")
    ], 8, De)) : (n(), l("span", He, [
      o(a.$slots, "default")
    ]));
  }
}), bt = /* @__PURE__ */ r({
  __name: "MNavbarItem",
  props: {
    end: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("li", {
      class: u(["m-navbar__item", { "--end": e.end }])
    }, [
      o(t.$slots, "default")
    ], 2));
  }
}), Re = {}, xe = { class: "m-navbar__items" };
function Ee(e, t) {
  return n(), l("ul", xe, [
    o(e.$slots, "default")
  ]);
}
const Ue = /* @__PURE__ */ _(Re, [["render", Ee]]), Pe = {}, qe = { class: "m-p" };
function Fe(e, t) {
  return n(), l("p", qe, [
    o(e.$slots, "default")
  ]);
}
const yt = /* @__PURE__ */ _(Pe, [["render", Fe]]), kt = /* @__PURE__ */ r({
  __name: "MRadio",
  props: {
    modelValue: {},
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (c) => t.value = c),
      type: "radio",
      class: "m-radio"
    }, null, 512)), [
      [U, t.value]
    ]);
  }
}), gt = /* @__PURE__ */ r({
  __name: "MSelect",
  props: /* @__PURE__ */ O({
    error: { type: Boolean }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("select", {
      "onUpdate:modelValue": s[0] || (s[0] = (c) => t.value = c),
      class: u(["m-select", [
        { "--error": e.error }
      ]])
    }, [
      o(a.$slots, "default")
    ], 2)), [
      [P, t.value]
    ]);
  }
}), Bt = /* @__PURE__ */ r({
  __name: "MSnackbar",
  props: {
    open: { type: Boolean, default: !1 },
    transition: { type: Boolean, default: !1 },
    position: { default: null }
  },
  setup(e) {
    const t = k(null);
    return A(() => e.open, (a) => {
      t.value && (a ? t.value.showPopover() : t.value.hidePopover());
    }), L(() => {
      e.open && t.value && t.value.showPopover();
    }), (a, s) => (n(), l("div", {
      ref_key: "snackbarRef",
      ref: t,
      popover: "manual",
      class: u(["m-snackbar", [
        { "--transition": e.transition },
        e.position ? `--${e.position}` : ""
      ]])
    }, [
      a.$slots.default ? (n(), f(i(Je), { key: 0 }, {
        default: d(() => [
          o(a.$slots, "default"),
          a.$slots.actions ? (n(), f(i(je), { key: 0 }, {
            default: d(() => [
              o(a.$slots, "actions")
            ]),
            _: 3
          })) : h("", !0)
        ]),
        _: 3
      })) : h("", !0)
    ], 2));
  }
}), Ge = { class: "m-snackbar__actions" }, je = /* @__PURE__ */ r({
  __name: "MSnackbarActions",
  setup(e) {
    return (t, a) => (n(), l("div", Ge, [
      o(t.$slots, "default")
    ]));
  }
}), ze = { class: "m-snackbar__body" }, Je = /* @__PURE__ */ r({
  __name: "MSnackbarBody",
  setup(e) {
    return (t, a) => (n(), l("div", ze, [
      o(t.$slots, "default")
    ]));
  }
}), Ct = /* @__PURE__ */ r({
  __name: "MTabs",
  props: {
    transition: { type: Boolean },
    scrollhint: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (a, s) => (n(), l("div", {
      class: u(["m-tabs", [
        { "--transition": t.transition },
        { "--scrollhint": t.scrollhint }
      ]])
    }, [
      o(a.$slots, "default")
    ], 2));
  }
}), Ke = {}, Qe = {
  class: "m-tabs__list",
  role: "tablist"
};
function We(e, t) {
  return n(), l("div", Qe, [
    o(e.$slots, "default")
  ]);
}
const Vt = /* @__PURE__ */ _(Ke, [["render", We]]), Xe = ["aria-selected", "tabindex"], wt = /* @__PURE__ */ r({
  __name: "MTabsItem",
  props: {
    active: { type: Boolean, default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = t, s = (c) => {
      a("click", c);
    };
    return (c, $) => (n(), l("button", {
      type: "button",
      class: u(["m-tabs__item", [{ "--active": e.active }]]),
      role: "tab",
      "aria-selected": e.active ? "true" : "false",
      tabindex: e.active ? "0" : "-1",
      onClick: s
    }, [
      o(c.$slots, "default")
    ], 10, Xe));
  }
}), At = /* @__PURE__ */ r({
  __name: "MTextarea",
  props: /* @__PURE__ */ O({
    block: { type: Boolean },
    error: { type: Boolean },
    autoFit: { type: Boolean }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (c) => t.value = c),
      class: u(["m-textarea", [
        { "--block": e.block },
        { "--error": e.error },
        { "--auto-fit": e.autoFit }
      ]])
    }, null, 2)), [
      [q, t.value]
    ]);
  }
}), Lt = /* @__PURE__ */ r({
  __name: "MToggle",
  props: {
    modelValue: { type: Boolean },
    modelModifiers: {}
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = g(e, "modelValue");
    return (a, s) => B((n(), l("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (c) => t.value = c),
      type: "checkbox",
      class: "m-toggle"
    }, null, 512)), [
      [S, t.value]
    ]);
  }
}), Ye = ["data-columns-length"], Ot = /* @__PURE__ */ r({
  __name: "MColumns",
  props: {
    columnsLength: { default: null },
    autoFit: { type: Boolean, default: !1 },
    noGap: { type: Boolean, default: !1 },
    alignRows: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, a) => (n(), l("div", {
      class: u(["m-columns", [
        { "--auto-fit": e.autoFit },
        { "--no-gap": e.noGap },
        { "--align-rows": e.alignRows }
      ]]),
      "data-columns-length": e.columnsLength
    }, [
      o(t.$slots, "default")
    ], 10, Ye));
  }
}), Tt = /* @__PURE__ */ r({
  __name: "MContainer",
  props: {
    padding: { type: Boolean },
    noCentering: { type: Boolean }
  },
  setup(e) {
    const t = y(() => ({
      "--padding": e.padding,
      "--no-centering": e.noCentering
    }));
    return (a, s) => (n(), l("div", {
      class: u(["m-container", t.value])
    }, [
      o(a.$slots, "default")
    ], 2));
  }
});
export {
  tt as MAccordion,
  z as MAccordionContent,
  G as MAccordionSummary,
  at as MAlert,
  Q as MAlertActions,
  X as MAlertContent,
  Z as MAlertIcons,
  nt as MBadge,
  st as MBtn,
  ot as MCard,
  te as MCardActions,
  ne as MCardContent,
  lt as MCardImage,
  rt as MCheckbox,
  Ot as MColumns,
  Tt as MContainer,
  ct as MDialog,
  ut as MH1,
  it as MH2,
  dt as MH3,
  mt as MH4,
  ft as MH5,
  _t as MH6,
  $t as MInput,
  ht as MLabel,
  pt as MLink,
  vt as MNavbar,
  Ie as MNavbarHamburger,
  Ne as MNavbarHamburgerMenu,
  bt as MNavbarItem,
  Ue as MNavbarItems,
  Mt as MNavbarTitle,
  yt as MP,
  kt as MRadio,
  gt as MSelect,
  Bt as MSnackbar,
  je as MSnackbarActions,
  Je as MSnackbarBody,
  Ct as MTabs,
  wt as MTabsItem,
  Vt as MTabsList,
  At as MTextarea,
  Lt as MToggle
};
